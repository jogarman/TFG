/*
   RoboJop-----------------------------------------------------------------------------Septiembre de 2016
 ********************************************************************************************************
   Autor: Jose Garcia Manzanaro
   Tutora: Beatriz Garcia Vasallo
   Proyecto: Robot Bipedo Microcontrolado
   Trabajo Fin de Grado
   Universidad de Salamanca
   Contacto: josegm@usal.es

   English
   The code below is able to control autonomously a biped robot with 8 degrees of freedoom, specialy
   desing to be generated by 3D printing. This code control the movement step by step by a giroscope
   MPU5060 and can avoid obstacles with an ultrasonic sensor HC-SR04.

   Español
   El siguiente código es capaz de controlar de forma autónoma un robot bípedo de 8 grados de libertad
   diseñado para ser generado por una impresora 3D. Este código controla el movimiento posición a posición
   con ayuda de un giróscopo MPU5060 y evita obstaculos con ayuda de un sensor de ultrasonidos HC-SR04.
   ******************************************************************************************************
*/

//*******************************************************************************************************
// Comienzo de la definicion de variables y constantes **************************************************
//*******************************************************************************************************


//////////////////////////////////////////////////////
// Definicion de includes
//////////////////////////////////////////////////////

#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

//////////////////////////////////////////////////////
// Declaracion de constantes para el MPU
//////////////////////////////////////////////////////
const float pi = 3.1415926535897932384626433832795;
const float GraRad = 180 / pi;

//El acelerometro devuelve los valores que registra en un rango de numeros entre -16384 y +16384. Para
//conocer la aceleración exacta hay que divir el valor devuelto por el acelerómetro entre la sensibilidad 
//establecida en 2g.
//La siguinete cosnstante se utiliza para obtener los valores de la aceleración y obtener la inclinación
//con resultado en radianes.
const float AaR = 16384.00; //de Acelerometro A Radianes

//El giroscopo devuelve los valores registrados en el mismo rango que el acelerometro. La sensibilidad
//esta establecida en +-250º/s.
//Para determinar la velocidad angular se multiplica el valor registrado por la siguiente constante:
//+-250º/s= 32768/250= 131.072 datos*s/º
const float GaG = 131.072; //de Giroscopo A Grados

//////////////////////////////////////////////////////
// Declaracion de variables del MPU//////////////////
//////////////////////////////////////////////////////
MPU6050 mpu; // Definicion de la estructura de datos tipo MPU6050

int16_t ax, ay, az;//int16 define un integer con signo
int16_t gx, gy, gz;
float balanceoA, cabeceoA, balanceoG, cabeceoG, guinadaG, balanceo, cabeceo, guinada;
float ganancia = 0.9; //expresa el nivel de aceptacion entre el giroscopo y el acelerometro

//Valores que ajustan la inclinacion del MPU para que se corresponda con la cabeza
float calibracionCabeceo = -1, calibracionBalanceo = 2.8;

int tiempoChequeo = 250; //en milisegundos. Tiempo para el que se considera estable la señal del MPU
int dt = 5; //intervalo de tiempo por chequeo en milisegundos

//------------------------------Declaracion de variables del Ultrasonidos--------------------------------
const int pinEco = 3;
const int pinDisparo = 2;
const int distanciaSeguridad = 15; //distancia en cm a la que se detecta el obstaculo

//------------------------------Declaracion de variables de los LEDs ------------------------------------
const int pinRojo13 = 13;
const int pinVerde12 = 12;

//-------------------------------------------------------------------------------------------------------
// Relacion entre las definiciones de xxx0 y la rotula correspondiente
//-------------------------------------------------------------------------------------------------------
/*
  Las referencias relativas a los numeros se corresponden con articulaciones de la siguiente forma:
  xxx0 =>> pie izquierdo
  xxx1 =>> pie derecho
  xxx2 =>> rotula del tobillo izquierdo
  xxx3 =>> rotula del tobillo derecho
  xxx4 =>> rotula de la rodilla izquierda
  xxx5 =>> rotula de la rodilla derecha
  xxx6 =>> rotula de la cabeza izquierda
  xxx7 =>> rotula de la cabeza derecha

  Los angulos de las articulaciones tambien se denominan de la siguiente forma:
  Alfas son las articulaciones de los pies, Betas los tobillos, Gamma las rodillas
  y Delta los de la cabeza los enumerados como 1 son las articulaciones de la
  parte izquierda y los enumerados como 2 son las articulaciones de la derecha.
  P.Ej beta2 -> tobillo derecho
*/

//-----------------------------------
// TODOS LOS ANGULOS SON EN GRADOS
//-----------------------------------

//-----------------------------Declaracion de pines de los servos----------------------------------------
const int pinSer0 = 9;  //Pin del servo 0 (pie izq)
const int pinSer1 = 6;  //Pin del servo 1
const int pinSer2 = 8;  //Pin del servo 2
const int pinSer3 = 7;  //Pin del servo 3
const int pinSer4 = 10; //Pin del servo 4
const int pinSer5 = 5;  //Pin del servo 5
const int pinSer6 = 11; //Pin del servo 6
const int pinSer7 = 4;  //Pin del servo 7

//------------------------------Declaracion de los servos -----------------------------------------------
Servo ser0; // pie izq
Servo ser1; // pie der
Servo ser2; // r1 izq. r1 es la rotula del tobillo
Servo ser3; // r1 der
Servo ser4; // r2 izq. r2 es la rotula de la rodilla
Servo ser5; // r2 der
Servo ser6; // r3 izq. r3 es la rotula de la cabeza
Servo ser7; // r3 der

//----------------------------- Angulos entre las articulaciones ----------------------------------------
int ang0; // ang= angulo de la articulacion
int ang1;
int ang2;
int ang3;
int ang4;
int ang5;
int ang6;
int ang7;

//------------------------------
// Ajustes iniciales
//------------------------------
/*
  Calibramos el robot cada vez que lo montamos modificando el valor de ValIni.
  angIni es el angulo que tiene la articulacion para la posicion inicial.
  Por ejemplo, con ayuda de un transportador se coloca la articulación en el angulo angIni y se
  cambia el valor de valIni para que este valor del servo coincida con el valor de la articulacion.
*/
//----------------------------- Valores iniciales de los servos ----------------------------------------
//Valores para la posicion estatica. Son valores caracteristicos del montaje
int  valIni0 = 110;  // Pie izquierdo. Aumentar es a la derecha
int  valIni1 = 112; // Pie derecho. Aumentar es a la derecha
int  valIni2 = 90; // R1 izq  Aumentar el valor es abrir la articulacion
int  valIni3 = 77;  // R1 der  Aumentar el valor cerrar la articulacion
int  valIni4 = 72;  // R2 izq  Aumentar el valor es cerrar la articulacion
int  valIni5 = 121; // R2 der  Aumentar el valor es abrir la articulacion
int  valIni6 = 71;  // R3 izq  Aumentar el valor es abrir la articulacion
int  valIni7 = 131; // R3 der  Aumentar el valor es cerrar la articulacion

//----------------------------- Valores propios de las articulaciones -----------------------------------
/*
  Fijamos el angulo que queramos que tengan las articulaciones para la posicion de equilibro,
  esto es independientemente de como hallamos montado el robot
*/
int angIni0 = 90;
int angIni1 = 90;
int angIni2 = 121;
int angIni3 = 121;
int angIni4 = 114;
int angIni5 = 114;
int angIni6 = 175;
int angIni7 = 175;

//Se establece el sentido de giro para que abra o cierre como debe.
int sentido0 = +1;
int sentido1 = +1;
int sentido2 = +1;
int sentido3 = -1;
int sentido4 = -1;
int sentido5 = +1;
int sentido6 = +1;
int sentido7 = -1;

//valor de la reduccion para cada articulacion dada
float redu0 = 1.0;
float redu1 = 1.0;
float redu2 = 2.4;
float redu3 = 2.4;
float redu4 = 2.4;
float redu5 = 2.4;
float redu6 = 1.0;
float redu7 = 1.0;

//----------------------------- Variables globales de datos del giroscopo -------------------------------
int inicioA1; //giroscopoAlfa para la posicion de inicio. Pie. Referencia del giroscopo
int inicioA2;
int inicioD1; //giroscopoDelta para la posicion de inicio. Cabeza
int inicioD2;

//referencia para los pies tomada cuando se termina de inclinar hacia un lado con irHasta()
int incliA1;
int incliA2;

//----------------------------- Variables para el control de velocidad de ejecucion ---------------------
int velDef  = 200; //velocidad por defecto del programa principal (Caminar1)
int velDef2 = 200; //velocidad pro defecto del programa 2 (Caminar2)

//-------------------------------- Funcion para reiniciar el sistema ------------------------------------
void(* reset) (void) = 0; //resetea. Regresa a la posición 0 de memoria

//--------------------------------Variables del selector de ejecucion-----------------------------------
//Selecciona la forma de caminar
char estado = 0;
boolean preguntarCaminarPorDefecto = 1; //1 --> por defecto en Caminar 1. 0 --> espera a recibir el
                                        //numero del Caminar a ejecutar

//*******************************************************************************************************
// Fin de la definicion de variables y constantes. ******************************************************
//*******************************************************************************************************



//*******************************************************************************************************
// Comienzo del establecimiento de definiciones e inicializaciones para la ejecucion ********************
//*******************************************************************************************************

void setup() {
  //-------------------------- Deficinion de pines de los LEDs -----------------------------------------
  pinMode(pinRojo13, OUTPUT);
  pinMode(pinVerde12, OUTPUT);
  //pinMode(pinAzul3, OUTPUT);

  // ------------------ Definicion de pines del SENSOR DE ULTRASONIDOS HC-SR04 -------------------------
  pinMode(pinDisparo, OUTPUT);
  pinMode(pinEco, INPUT);

  //-------------------------------Iniciar canal de comunicacion ---------------------------------------
  Serial.begin(9600); //para detectar fallos en el programa y la seleccion de ejecucion
  Serial.println("Conectado");

  // ------------------------------Inicializacion del giroscopo----------------------------------------
  mpu.initialize();
  // Solo para depuracion
  //Serial.println(mpu.testConnection() ? "Connected" : "Connection failed");

  //----------------------------- Asignacion de pines de los servos ------------------------------------
  ser0.attach(pinSer0);  //Cable negro
  ser1.attach(pinSer1);  //Cable amarillo
  ser2.attach(pinSer2);  //Cable verde
  ser3.attach(pinSer3);  //Cable rojo
  ser4.attach(pinSer4);  //Cable verde
  ser5.attach(pinSer5);  //Cable verde
  ser6.attach(pinSer6);  //Cable verde
  ser7.attach(pinSer7);  //Cable rojo
}
//*******************************************************************************************************
// Fin del establecimiento de definiciones e inicializaciones para la ejecucion. ************************
//*******************************************************************************************************

//*******************************************************************************************************
//*******************************************************************************************************
// Comienzo de la ejecucion *****************************************************************************
//*******************************************************************************************************
//*******************************************************************************************************
void loop() {
  //------------------------------ Seleccion de Caminar -------------------------------
  if (preguntarCaminarPorDefecto == 1) {//para entrar por defecto al caminar1 si se activa el boolean
    Caminar1();
  }
  Serial.println("Introduzca el numero del programa que desea ejecutar");
  do {
    estado = Serial.read();  // El bucle permanece hasta que le llega uno de los caracteres 1, 2 o 3.
  } while  (estado != '1' and estado != '2' and estado != '3'); //cuando estado no es igual a 1, 2 ni 3
  //repite

  //pasa al programa de caminar elegido
  if (estado == '1') {
    Caminar1();
  }
  else if (estado == '2') {
    Caminar2();
  }
  else if (estado == '3') {
    Caminar3();
  }
}
//*******************************************************************************************************
// Fin de la ejecucion (loop) ***************************************************************************
//*******************************************************************************************************

///////////////////////////////////////////////////////////////////////
// Camina con giroscopo y evita obstaculos *************************///
///////////////////////////////////////////////////////////////////////
void Caminar1() {
  Calibracion(); //va a la posicion de inicio.
  delay (500);// este valor se aumenta cuando se quieren calibrar los servos
  posicionInicio(90, 90, 121, 121, 114, 114, 175, 175, 2000);//la posicion de prueba
  //Bucle infinito: se inclina, da una zancada a la derecha, se inclina, zancada a la
  //izquierda, se inclina, y así, sucesivamente
  //Al final de cada zancada chequea si hay algún obstaculo y lo rodea
  while (true) {
    irHasta(-8);      //- es inclinar a la izquierda y + es inclinar a la derecha
    zancadaDerecha();
    evitarDesdeDerecha();
    irHasta(8);
    zancadaIzquierda();
    evitarDesdeIzquierda();
  }
}

///////////////////////////////////////////////////////////////////////
// Camina rápido para demostracion *********************************///
///////////////////////////////////////////////////////////////////////
void Caminar2() {
  Calibracion(); //va a la posicion de inicio
  delay(1000);

  //da media zancada hasta situarse en una posición que pueda enlazar con la siguiente
  while (true) {
    IrAP2( 90,  90, 121, 121, 114, 114, 175, 175, velDef2);
    IrAP2( 93,  93, 121, 121, 114, 114, 175, 175, velDef2);
    IrAP2( 96,  96, 121, 121, 114, 114, 175, 175, velDef2);
    IrAP2( 99,  99, 121, 121, 114, 114, 175, 175, velDef2);
    IrAP2(101, 101, 121, 121, 114, 114, 175, 175, velDef2);
    IrAP2(103, 103, 121, 121, 114, 114, 175, 175, velDef2);
  }

  IrAP2(103, 102, 121, 118, 114, 110, 175, 175, velDef2);
  IrAP2(103, 101, 121, 115, 114, 106, 175, 175, velDef2);
  IrAP2(103, 100, 121, 118, 114, 102, 175, 175, velDef2);
  IrAP2(100,  99, 118, 124, 114,  98, 185, 173, velDef2);
  IrAP2( 99,  99, 116, 126, 114, 102, 187, 171, velDef2);
  IrAP2( 99,  99, 114, 128, 114, 102, 180, 172, velDef2);
  IrAP2( 99,  99, 112, 130, 114, 102, 175, 174, velDef2);
  IrAP2( 97,  96, 112, 130, 114, 102, 175, 175, velDef2);
  IrAP2( 95,  93, 112, 130, 114, 103, 175, 175, velDef2);
  IrAP2( 80,  80, 112, 130, 114, 104, 175, 175, velDef2);
  IrAP2( 80,  78, 116, 126, 116, 108, 173, 178, velDef2);
  IrAP2( 80,  78, 116, 126, 110, 108, 173, 178, velDef2);
  IrAP2( 80,  78, 116, 126, 105, 108, 173, 178, velDef2);
  IrAP2( 80,  78, 125, 126,  92, 108, 170, 180, velDef2);
  IrAP2( 80,  78, 125, 126,  91, 108, 168, 180, velDef2);
  IrAP2( 80,  78, 125, 126,  90, 108, 167, 180, velDef2);
  IrAP2( 80,  78, 130, 126,  89, 108, 164, 180, velDef2);
  IrAP2( 80,  78, 135, 126,  88, 108, 160, 180, velDef2);
  IrAP2( 81,  79, 140, 125,  87, 108, 160, 180, velDef2);
  IrAP2( 82,  81, 140, 123,  88, 108, 160, 180, velDef2);
  IrAP2( 82,  82, 140, 122,  89, 108, 160, 180, velDef2);
  IrAP2( 82,  82, 140, 121,  91, 108, 160, 178, velDef2);
  IrAP2( 85,  85, 140, 118,  91, 108, 165, 175, velDef2);
  IrAP2( 88,  88, 140, 115,  91, 108, 170, 172, velDef2);
  IrAP2( 90,  90, 139, 113,  94, 111, 175, 169, velDef2);
  IrAP2( 90,  90, 137, 111,  97, 115, 175, 169, velDef2);
  IrAP2( 90,  90, 135, 108, 100, 118, 175, 169, velDef2);
  IrAP2( 90,  90, 132, 105, 105, 121, 175, 169, velDef2);
  IrAP2( 92,  92, 130, 105, 108, 125, 175, 172, velDef2);
  IrAP2( 94,  94, 127, 105, 110, 127, 175, 174, velDef2);
  IrAP2( 97,  97, 120, 105, 112, 129, 175, 174, velDef2);
  IrAP2(100, 100, 120, 115, 115, 125, 175, 175, velDef2);
  IrAP2(103, 103, 121, 121, 115, 120, 175, 175, velDef2);
  IrAP2(103, 103, 121, 121, 114, 114, 175, 175, velDef2);
}

//--------------- programa vacante ------------------------
void Caminar3() {
  arcoIris();
}

//////////////////////////////////////////////////////
// Fuciones auxiliares **************************** //
//////////////////////////////////////////////////////
//---------------------Ayuda a calibrar el robot--------------------
void Calibracion() {
  ser0.write(valIni0);
  ser1.write(valIni1);
  ser2.write(valIni2);
  ser3.write(valIni3);
  ser4.write(valIni4);
  ser5.write(valIni5);
  ser6.write(valIni6);
  ser7.write(valIni7);
}

//-----------------------------Posicion de inicio con datos proporcionados por el giroscopo--------------
//----------El siguiente código posiciona la cabeza y los pies paralelos al suelo------------------------
void posicionInicio(int ang0, int ang1, int ang2,
                    int ang3, int ang4, int ang5,
                    int ang6, int ang7, int tiempoInicio) {

  boolean i;
  int contadorParaPasarBalanceo = 0;
  int contadorParaPasarCabeceo = 0;
  byte necesariosParaPasar = 30; //con 30 va bien, con 50 muy bien, pero tarda demasiado
  byte margenError = 1;          //+- grados de margen de error en la colocacion
  float giroAlfa1 = ang0 - balanceo,
        giroAlfa2 = ang1 - balanceo,
        giroDelta1 = ang6,
        giroDelta2 = ang7;

  ///////////////////////////////////////////////////////////////////////////////////////////////////////
  //do while, inicia un contador de balanceo y otro de cabeceo. El siguiente codigo hace que se necesiten
  //tres condiciones para pasar:
  //       -que pasen 2  segundos
  //       -que se halla llegado a la posicion de equilibro en balanceo (+-1º) 30 veces
  //       -que se halla llegado a la posicion de equilibro en cabeceo (+-1º)  30 veces
  ///////////////////////////////////////////////////////////////////////////////////////////////////////

  do {
    //tiempoInicio=2000ms/dt=5ms hace un minimo de 400 calculos.
    for (int n = 0; n < tiempoInicio / dt; n++) {
      mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
      //Balanceo y cabeceo obtenidos de la aceleracion
      balanceoA = atan((az / AaR) / sqrt(pow((ay / AaR), 2) + pow((ax / AaR), 2))) * GraRad 
        + calibracionBalanceo;
      cabeceoA  = atan((ay / AaR) / sqrt(pow((ax / AaR), 2) + pow((az / AaR), 2))) * GraRad 
        + calibracionCabeceo;
      //Con este if hacemos que la primera señal del balanceo sea la del acelerometro y el resto 
      //provengan del resultado del filtro. Se consigue un proceso algo mas rapido.
      if (i == 0) {
        balanceoG = balanceoA + (gz / GaG) * dt / 1000; 
        cabeceoG  = cabeceoA  + (gy / GaG) * dt / 1000;
        i++;
      }
      //angulo=anguloAnterior+ (velocidadAngular/131.072)*dt  dt corresponde con el delay
      else {
        balanceoG = balanceo + (gz / GaG) * dt / 1000; //gz*sensibilidad. GaR (de giroscopo a Grados)[GaR=1
        cabeceoG  = cabeceo  + (gy / GaG) * dt / 1000; //sensibilidad] es la inversa de la sensibilidad
      }
      balanceo  = (ganancia * balanceoG + (1 - ganancia) * balanceoA);
      cabeceo   = (ganancia * cabeceoG  + (1 - ganancia) * cabeceoA);
      delay(dt);

      //-------------------------------------------------------------------------------------------------
      // Estabilizacion   -------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------
      /*
         Cambia la posición de la cabeza 1 de cada 10 veces que se toma la posicion
         La toma de datos va mucho mas rapido que la respuesta de los servos. Estos tienen una
         velocidad de 6º/10ms pero un arranque lento, si cambiaran de posicion cada 5 ms, se
         produciria un cabeceo indeseado.
         Cada 10 veces se estabiliza bien.
      */
      if (n % 10 == 0) {
        // ------------- Gestion del balanceo  ------------------
        if (balanceo < -margenError) {
          giroAlfa1--;
          giroAlfa2--;
        }
        else if (balanceo > margenError) {
          giroAlfa1++;
          giroAlfa2++;
        }
        else {
          contadorParaPasarBalanceo++;
        }
        // ------------- Gestion del cabeceo  ------------------
        if (cabeceo > margenError) {
          giroDelta1--;
          giroDelta2--;
        }
        else if (cabeceo < -margenError) {
          giroDelta1++;
          giroDelta2++;
        }
        else {
          contadorParaPasarCabeceo++;
        }

        IrA(giroAlfa1, giroAlfa2, ang2, ang3, ang4, ang5, giroDelta1, giroDelta2);
      }
    }
    ledOff();

    // Deja pasar la ejecucion cuando se alcanza el minimo requerido en los contadores
  } while (contadorParaPasarBalanceo < necesariosParaPasar 
    and contadorParaPasarCabeceo < necesariosParaPasar);

  //----------------------------------------------------------------------------------------------------
  // inicioAlfa e inicioDelta se usaran en la siguiente funcion.
  // El 0.5 es para redondear. Sin el 0.5 simplemente se truncan los decimales (6.9->6)
  // pero con +0.5 se redondea => 6.9+0.5=7.4->7.
  //----------------------------------------------------------------------------------------------------
  inicioA1 = giroAlfa1 + 0.5;
  inicioA2 = giroAlfa2 + 0.5;
  inicioD1 = giroDelta1 + 0.5;
  inicioD2 = giroDelta2 + 0.5;
}

//------------------------- Desplaza la pierna derecha adelante ----------------------------------------
void zancadaDerecha() {
  ledOff();
  irAPaso(incliA1,     incliA2 - 1,  121, 118, 114, 110, 175, 175, velDef);
  irAPaso(incliA1,     incliA2 - 2,  121, 115, 114, 106, 175, 177, velDef);
  irAPaso(incliA1,     incliA2 - 2,  121, 118, 114, 102, 175, 180, velDef);
  irAPaso(incliA1 - 3, incliA2 - 2,  118, 120, 114,  98, 185, 183, velDef);
  irAPaso(incliA1 - 4, incliA2 - 2,  116, 125, 114,  98, 187, 183, velDef);
  irAPaso(incliA1 - 4, incliA2 - 2,  114, 125, 114,  98, 180, 183, velDef);
  irAPaso(incliA1 - 4, incliA2 - 2,  112, 125, 114,  98, 175, 180, velDef);
  irAPaso(incliA1 - 7, incliA2 - 2,  112, 125, 114,  98, 175, 177, velDef);
  irAPaso(incliA1 - 8, incliA2 - 10, 112, 125, 114, 100, 175, 175, velDef);
  irAPaso(inicioA1,    inicioA2 ,    112, 126, 114, 103, 175, 175, velDef);
}

//--------------------------- Detecta un obstaculo y gira a la izquierda--------------------------------
void evitarDesdeDerecha() {
  long cm = ping();
  if (cm > 15 or cm == 0) {
    verde();
    delay(400);
    ledOff();
  }
  else {
    rojo();
    delay(400);
    ledOff();
    delay(400);
    rojo();

    //Realiza el movimiento de giro a la izquierda 8 veces
    for (int i = 0; i < 8; i++) {
      giroDesdeDerecha();
      irHasta(-10);
      zancadaDerecha();
      ledOff();
    }
  }
}

//---------------- Gira desde zancadaDerecha -----------------------------------------------------------
//Esta posicion hace rotar el robot y enlaza con una posicion desde la que zancada derecha
//puede avanzar.
void giroDesdeDerecha() {
  irAPaso(inicioA1, inicioA2 , 120, 120, 114, 114, 175, 175, velDef);
}

//-------------------- Desplaza la pierna izquierda adelante -------------------------------------------
void zancadaIzquierda() {
  ledOff();
  irAPaso(incliA1,     incliA2,     120, 130, 114, 104, 175, 175, velDef);
  irAPaso(incliA1,     incliA2,     120, 126, 116, 104, 174, 178, velDef);
  irAPaso(incliA1,     incliA2,     120, 126, 110, 104, 173, 178, velDef);
  irAPaso(incliA1,     incliA2,     120, 126, 105, 104, 172, 178, velDef);
  irAPaso(incliA1,     incliA2,     125, 126, 100, 104, 171, 180, velDef);
  irAPaso(incliA1,     incliA2,     125, 126, 100, 104, 170, 180, velDef);
  irAPaso(incliA1,     incliA2,     130, 126, 100, 104, 170, 180, velDef);
  irAPaso(incliA1,     incliA2,     130, 126,  97, 104, 170, 180, velDef);
  irAPaso(incliA1,     incliA2,     135, 126,  97, 104, 170, 180, velDef);
  irAPaso(incliA1 + 1, incliA2,     135, 125,  97, 104, 171, 179, velDef);
  irAPaso(incliA1 + 2, incliA2 + 1, 135, 125,  97, 104, 172, 178, velDef);
  irAPaso(incliA1 + 2, incliA2 + 2, 132, 121, 100, 104, 173, 177, velDef);
  irAPaso(incliA1 + 4, incliA2 + 4, 129, 119, 100, 104, 174, 176, velDef);
  irAPaso(incliA1 + 6, incliA2 + 6, 126, 118, 100, 104, 175, 175, velDef);
}

//Si detecta un obstaculo a menos de 15 cm lo evita
void evitarDesdeIzquierda() {
  long cm = ping();
  if (cm > 15 or cm == 0) {
    verde();
    delay(400);
    ledOff();
  }
  else {
    rojo();
    delay(400);
    ledOff();
    delay(400);
    rojo();

    //realiza el movimiento de giro a la derecha 8 veces
    for (int i = 0; i < 8; i++) {
      giroDesdeIzquierda();
      irHasta(10);
      zancadaIzquierda();
      ledOff();
    }
  }
}
//-------------------- Desplaza la pierna izquierda adelante -------------------------------------------
void giroDesdeIzquierda() {
  irAPaso(inicioA1, inicioA1, 118, 126, 105, 100, 175, 175, velDef);
  irAPaso(inicioA1, inicioA1, 120, 125, 105, 100, 175, 178, velDef);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funciones de movimiento /////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
   Las siguientes funciones reciben los angulos de las articulaciones. Alfas son los servos de los pies,
   Betas los tobillos, Gamma las rodillas y Delta los de la cabeza. Los enumerados como 1 son las 
   articulaciones de la parte izquierda y los enumerados como 2 son las articulaciones de la derecha.
*/
//----IrAPaso() se le proporcionan los angulos entre las articulaciones y coloca los servos en posicion--
void irAPaso(int alfa1,  int alfa2,
             int beta1, int beta2,
             int gamma1, int gamma2,
             int delta1, int delta2,
             int velocidad) {
  testCaida();//detecta si se ha caido y se reinicia
  tomarDatosMPU();//devuelve balanceo y cabeceo
  IrA( alfa1,  alfa2,   beta1,  beta2,  gamma1,  gamma2,  delta1,  delta2);
  //el testeo de la inclinacion lleva un tiempo (tiempoChequeo). El siguiente if sirve para comparar el 
  //tiempo de espera que debe tener con el tiempo que tarda en hacer la toma de datos del MPU.
  //Si la toma de datos tarda mas que el tiempo de espera no hace delay,  y si tarda menos, se
  //calcula la diferencia entre ambos
  if (velocidad - tiempoChequeo > 0) {
    delay(velocidad - tiempoChequeo);
  }
}

//------------------------IrA() pasa el angulo de las articulaciones a los servos-----------------------
void IrA(int alfa1, int alfa2,
         int beta1, int beta2,
         int gamma1, int gamma2,
         int delta1, int delta2) {

  //Coloca cada servo en el angulo al que se le ha mandado
  ser0.write(redu0 * sentido0 * (alfa1 - angIni0) + valIni0);
  ser1.write(redu1 * sentido1 * (alfa2 - angIni1) + valIni1);
  ser2.write(redu2 * sentido2 * (beta1 - angIni2) + valIni2);
  ser3.write(redu3 * sentido3 * (beta2 - angIni3) + valIni3);
  ser4.write(redu4 * sentido4 * (gamma1 - angIni4) + valIni4);
  ser5.write(redu5 * sentido5 * (gamma2 - angIni5) + valIni5);
  ser6.write(redu6 * sentido6 * (delta1 - angIni6) + valIni6);
  ser7.write(redu7 * sentido7 * (delta2 - angIni7) + valIni7);
}

//---------------------------------IrAP2 solo se utiliza en el Caminar2---------------------------------

//Coloca cada servo en el angulo al que se le ha mandado y espera un tiempo "velocidad"
void IrAP2(int alfa1, int alfa2,
           int beta1, int beta2,
           int gamma1, int gamma2,
           int delta1, int delta2,
           int velocidad) {
  IrA( alfa1,  alfa2,   beta1,  beta2,  gamma1,  gamma2,  delta1,  delta2);
  delay(velocidad);
}

//--------------------------------------------irHasta--------------------------------------------------
//Es una rutina para ir hasta un angulo en el eje Y, en el balanceo, controlado solo por los
//servos de los pies

void irHasta(int angHasta) {
  int alfa1 = inicioA1;
  int alfa2 = inicioA2;
  if (angHasta < 0) {
    do {
      tomarDatosMPU();
      // se modifica balanceo
      alfa1++;
      alfa2++;
      ser0.write(redu0 * sentido0 * (alfa1 - angIni0) + valIni0);
      ser1.write(redu1 * sentido1 * (alfa2 - angIni1) + valIni1);
    } while (balanceo > angHasta);
  }
  else if (angHasta > 0) {
    do {
      tomarDatosMPU();
      alfa1--;
      alfa2--;
      ser0.write(redu0 * sentido0 * (alfa1 - angIni0) + valIni0);
      ser1.write(redu1 * sentido1 * (alfa2 - angIni1) + valIni1);
    } while (balanceo < angHasta);
  }
  incliA1 = alfa1;
  incliA2 = alfa2;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
////////// Otras funciones ////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------Obtencion datos del giroscopo------------------------------
void tomarDatosMPU() {

 //Codigo basado en los siguientes blogs: http://robologs.net/2014/10/15/tutorial-de-arduino-y-mpu-6050/
 //y http://www.circuitmagic.com/arduino/control-dc-motor-cwccw-with-mpu-6050-gyroaccelerometer-arduino/

 int i;
  for (int n = 0; n < tiempoChequeo / dt; n++) { //tiempoChequeo=300ms/dt=5 hacen son 60 calculos. 
   //Con estos valores se obtiene una buena precision en un periodo de tiempo corto
   mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
   //Balanceo y cabeceo obtenidos de la aceleracion
  balanceoA = atan((az / AaR) / sqrt(pow((ay / AaR), 2) + pow((ax / AaR), 2))) * GraRad + calibracionBalanceo;
  cabeceoA  = atan((ay / AaR) / sqrt(pow((ax / AaR), 2) + pow((az / AaR), 2))) * GraRad + calibracionCabeceo;

    //Con este if hacemos que la primera señal del balanceo sea la del acelerometro y el resto provengan
    //del resultado del filtro, así hacemos que sea algo mas rapido
    if (i == 0) {
      balanceoG = balanceoA + (gz / GaG) * dt / 1000; //angulo=anguloAnterior+ (velocidadAngular/131.072)*dt  
      cabeceoG  = cabeceoA  + (gy / GaG) * dt / 1000; //angulo=anguloAnterior+ (velocidadAngular/131.072)*dt
      i++;
    }
    else {
      balanceoG = balanceo + (gz / GaG) * dt / 1000; //gz*sensibilidad. GaR (de giroscopo a Grados) 
      cabeceoG  = cabeceo  + (gy / GaG) * dt / 1000; //[GaR=1/sensibilidad] es la inversa de la sensibilidad
    }
    //Filtro complementario. Funciona bien para una ganancia de 0.9
    balanceo = (ganancia * balanceoG + (1 - ganancia) * balanceoA);
    cabeceo  = (ganancia * cabeceoG  + (1 - ganancia) * cabeceoA);
    delay(dt);
  }
}

//-------Codigo del sensor de ultrasonidos. Devuelve la distancia que hay con el objeto de delante-----
long ping() {
  long duracion, distanciaEnCm;

  digitalWrite(pinDisparo, LOW);  //para generar un pulso limpio ponemos a LOW 4us
  delayMicroseconds(4);
  digitalWrite(pinDisparo, HIGH);  //generamos el disparo de 10us
  delayMicroseconds(10);
  digitalWrite(pinDisparo, LOW);

  duracion = pulseIn(pinEco, HIGH);  //medimos el tiempo entre el pulso enviado y el recibido,
  //en microsegundos
  distanciaEnCm = duracion / 58;  //29*2=58. *donde 1/29 es la velocidad del sonido medido en 
  //cm/microsegundos.

  return distanciaEnCm;
}

// --------------------- Detecta la perdida de estabilidad (angulo de inclinacion > 45º) --------------
void testCaida() { //detecta que se ha caido, luce todo, parpadea y se reinicia
  if (balanceo < -45 or 45 < balanceo or cabeceo < -45 or cabeceo > 45) {
    rojo();
    delay(500);
    ledOff();
    delay(500);
    rojo();
    delay(500);
    reset();//se reinicia
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Funciones de colores //////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
//Se definen y configuran colores, así como rutinas para apagarlos
void ledOn()  {
  color(255, 255, 255);
}
void rojo()   {
  color(255, 0, 0);
}
void verde()  {
  color (0, 255, 0);
}
void azul()   {
  color (0, 0, 255);
}
void morado() {
  color(255, 0, 200);
}
void cian()   {
  color (0, 255, 250);
}

void ledOff()   {
  color(0, 0, 0);
}
void rojoOff()  {
  analogWrite(pinRojo13,  0);
}
void verdeOff() {
  analogWrite(pinVerde12, 0);
}
//void azulOff() {
//analogWrite(3, 0);} // Pin 3 ocupado

void arcoIris() {
  int tiempoArcoiris = 3000; //fue empleado para chequear los contactos de los Leds al iniciar el programa
  color(255, 0, 0);
  delay(tiempoArcoiris / 3);
  color(0, 255, 0);
  delay(tiempoArcoiris / 3);
  color(0, 0, 255);
  delay(tiempoArcoiris / 3);
  ledOff();
}

//Se definen los pines a los que van conectados los LEDs
void color(byte red, byte green, byte blue) {
  analogWrite(pinRojo13, red);
  analogWrite(pinVerde12, green);
  //analogWrite(3, blue); //desnombrar y asociar si se conecta.
}
